/*
 * This class generated by com.mchange.v2.c3p0.codegen.JdbcProxyGenerator$NewProxyAnyStatementGenerator
 * Sat Jan 26 13:40:43 CST 2013
 * DO NOT HAND EDIT!!!!
 */
package com.mchange.v2.c3p0.impl;

import com.mchange.v2.c3p0.C3P0ProxyStatement;
import java.io.InputStream;
import java.io.Reader;
import java.lang.Class;
import java.lang.Object;
import java.lang.String;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Calendar;
import java.sql.*;
import javax.sql.*;
import com.mchange.v2.log.*;
import java.lang.reflect.Method;
import com.mchange.v2.sql.SqlUtils;
import java.lang.reflect.InvocationTargetException;

public final class NewProxyPreparedStatement implements PreparedStatement, C3P0ProxyStatement
{
	protected PreparedStatement inner;
	
	public NewProxyPreparedStatement(PreparedStatement inner)
	{ this.inner = inner; }
	
	public final ResultSetMetaData getMetaData() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getMetaData();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void addBatch() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.addBatch();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final ResultSet executeQuery() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			ResultSet innerResultSet = inner.executeQuery();
			if (innerResultSet == null) return null;
			parentPooledConnection.markActiveResultSetForStatement( inner, innerResultSet );
			return new NewProxyResultSet( innerResultSet, parentPooledConnection, inner, this );
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int executeUpdate() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.executeUpdate();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void clearParameters() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.clearParameters();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final ParameterMetaData getParameterMetaData() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getParameterMetaData();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setArray(int a, Array b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setArray(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setAsciiStream(int a, InputStream b, int c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setAsciiStream(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setAsciiStream(int a, InputStream b, long c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setAsciiStream(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setAsciiStream(int a, InputStream b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setAsciiStream(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setBigDecimal(int a, BigDecimal b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setBigDecimal(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setBinaryStream(int a, InputStream b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setBinaryStream(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setBinaryStream(int a, InputStream b, long c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setBinaryStream(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setBinaryStream(int a, InputStream b, int c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setBinaryStream(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setBlob(int a, InputStream b, long c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setBlob(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setBlob(int a, InputStream b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setBlob(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setBlob(int a, Blob b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setBlob(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setBytes(int a, byte[] b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setBytes(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setClob(int a, Reader b, long c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setClob(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setClob(int a, Reader b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setClob(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setClob(int a, Clob b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setClob(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setNCharacterStream(int a, Reader b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setNCharacterStream(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setNCharacterStream(int a, Reader b, long c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setNCharacterStream(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setNClob(int a, Reader b, long c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setNClob(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setNClob(int a, NClob b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setNClob(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setNClob(int a, Reader b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setNClob(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setNString(int a, String b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setNString(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setNull(int a, int b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setNull(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setNull(int a, int b, String c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setNull(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setRef(int a, Ref b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setRef(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setRowId(int a, RowId b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setRowId(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setSQLXML(int a, SQLXML b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setSQLXML(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setUnicodeStream(int a, InputStream b, int c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setUnicodeStream(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setBoolean(int a, boolean b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setBoolean(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setByte(int a, byte b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setByte(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setDouble(int a, double b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setDouble(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setFloat(int a, float b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setFloat(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setInt(int a, int b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setInt(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setLong(int a, long b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setLong(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setShort(int a, short b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setShort(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setTimestamp(int a, Timestamp b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setTimestamp(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setTimestamp(int a, Timestamp b, Calendar c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setTimestamp(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setURL(int a, URL b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setURL(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final boolean execute() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.execute();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setTime(int a, Time b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setTime(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setTime(int a, Time b, Calendar c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setTime(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setObject(int a, Object b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setObject(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setObject(int a, Object b, int c, int d) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setObject(a, b, c, d);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setObject(int a, Object b, int c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setObject(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setDate(int a, Date b, Calendar c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setDate(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setDate(int a, Date b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setDate(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setCharacterStream(int a, Reader b, long c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setCharacterStream(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setCharacterStream(int a, Reader b, int c) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setCharacterStream(a, b, c);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setCharacterStream(int a, Reader b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setCharacterStream(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setString(int a, String b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setString(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void addBatch(String a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.addBatch(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void clearBatch() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.clearBatch();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void clearWarnings() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.clearWarnings();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int[] executeBatch() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.executeBatch();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final ResultSet executeQuery(String a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			ResultSet innerResultSet = inner.executeQuery(a);
			if (innerResultSet == null) return null;
			parentPooledConnection.markActiveResultSetForStatement( inner, innerResultSet );
			return new NewProxyResultSet( innerResultSet, parentPooledConnection, inner, this );
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int executeUpdate(String a, int[] b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.executeUpdate(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int executeUpdate(String a, int b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.executeUpdate(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int executeUpdate(String a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.executeUpdate(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int executeUpdate(String a, String[] b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.executeUpdate(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int getFetchDirection() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getFetchDirection();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int getFetchSize() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getFetchSize();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final ResultSet getGeneratedKeys() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			ResultSet innerResultSet = inner.getGeneratedKeys();
			if (innerResultSet == null) return null;
			parentPooledConnection.markActiveResultSetForStatement( inner, innerResultSet );
			return new NewProxyResultSet( innerResultSet, parentPooledConnection, inner, this );
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int getMaxFieldSize() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getMaxFieldSize();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int getMaxRows() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getMaxRows();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final boolean getMoreResults() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getMoreResults();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final boolean getMoreResults(int a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getMoreResults(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int getQueryTimeout() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getQueryTimeout();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final ResultSet getResultSet() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			ResultSet innerResultSet = inner.getResultSet();
			if (innerResultSet == null) return null;
			parentPooledConnection.markActiveResultSetForStatement( inner, innerResultSet );
			return new NewProxyResultSet( innerResultSet, parentPooledConnection, inner, this );
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int getResultSetConcurrency() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getResultSetConcurrency();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int getResultSetHoldability() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getResultSetHoldability();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int getResultSetType() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getResultSetType();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final int getUpdateCount() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getUpdateCount();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final SQLWarning getWarnings() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.getWarnings();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final boolean isPoolable() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.isPoolable();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setCursorName(String a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setCursorName(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setEscapeProcessing(boolean a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setEscapeProcessing(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setFetchDirection(int a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setFetchDirection(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setFetchSize(int a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setFetchSize(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setMaxFieldSize(int a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setMaxFieldSize(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setMaxRows(int a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setMaxRows(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setPoolable(boolean a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setPoolable(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void setQueryTimeout(int a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.setQueryTimeout(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void close() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			if (! this.isDetached())
			{
				if ( is_cached )
					parentPooledConnection.checkinStatement( inner );
				else
				{
					parentPooledConnection.markInactiveUncachedStatement( inner );
					try{ inner.close(); }
					catch (Exception e )
					{
						if (logger.isLoggable( MLevel.WARNING ))
							logger.log( MLevel.WARNING, "Exception on close of inner statement.", e);
						SQLException sqle = SqlUtils.toSQLException( e );
						throw sqle;
					}
				}
				
				this.detach();
				this.inner = null;
				this.creatorProxy = null;
			}
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				if (Debug.DEBUG && logger.isLoggable( MLevel.FINE ))
				{
					logger.log( MLevel.FINE, this + ": close() called more than once." );
				}
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final boolean execute(String a, int[] b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.execute(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final boolean execute(String a, String[] b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.execute(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final boolean execute(String a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.execute(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final boolean execute(String a, int b) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.execute(a, b);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final void cancel() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			inner.cancel();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final Connection getConnection() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			if (! this.isDetached())
				return creatorProxy;
			else
				throw new SQLException("You cannot operate on a closed Statement!");
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final boolean isClosed() throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return this.isDetached();
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final boolean isWrapperFor(Class a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.isWrapperFor(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	public final Object unwrap(Class a) throws SQLException
	{
		try
		{
			maybeDirtyTransaction();
			
			return inner.unwrap(a);
		}
		catch (NullPointerException exc)
		{
			if ( this.isDetached() )
			{
				throw SqlUtils.toSQLException("You can't operate on a closed Statement!!!", exc);
			}
			else throw exc;
		}
		catch (Exception exc)
		{
			if (! this.isDetached())
			{
				throw parentPooledConnection.handleThrowable( exc );
			}
			else throw SqlUtils.toSQLException( exc );
		}
	}
	
	private final static MLogger logger = MLog.getLogger( "com.mchange.v2.c3p0.impl.NewProxyPreparedStatement" );
	
	volatile NewPooledConnection parentPooledConnection;
	
	ConnectionEventListener cel = new ConnectionEventListener()
	{
		public void connectionErrorOccurred(ConnectionEvent evt)
		{ /* DON'T detach()... IGNORE -- this could be an ordinary error. Leave it to the PooledConnection to test, but leave proxies intact */ }
		
		public void connectionClosed(ConnectionEvent evt)
		{ detach(); }
	};
	
	void attach( NewPooledConnection parentPooledConnection )
	{
		this.parentPooledConnection = parentPooledConnection;
		parentPooledConnection.addConnectionEventListener( cel );
	}
	
	private void detach()
	{
		parentPooledConnection.removeConnectionEventListener( cel );
		parentPooledConnection = null;
	}
	
	NewProxyPreparedStatement( PreparedStatement inner, NewPooledConnection parentPooledConnection )
	{
		this( inner );
		attach( parentPooledConnection );
	}
	
	boolean isDetached()
	{ return (this.parentPooledConnection == null); }
	
	boolean is_cached;
	NewProxyConnection creatorProxy;
	
	NewProxyPreparedStatement( PreparedStatement inner, NewPooledConnection parentPooledConnection, boolean cached, NewProxyConnection cProxy )
	{
		this( inner, parentPooledConnection );
		this.is_cached = cached;
		this.creatorProxy = cProxy;
	}
	
	public Object rawStatementOperation(Method m, Object target, Object[] args) throws IllegalAccessException, InvocationTargetException, SQLException
	{
		maybeDirtyTransaction();
		
		if (target == C3P0ProxyStatement.RAW_STATEMENT) target = inner;
		for (int i = 0, len = args.length; i < len; ++i)
			if (args[i] == C3P0ProxyStatement.RAW_STATEMENT) args[i] = inner;
		Object out = m.invoke(target, args);
		if (out instanceof ResultSet)
		{
			ResultSet innerResultSet = (ResultSet) out;
			parentPooledConnection.markActiveResultSetForStatement( inner, innerResultSet );
			out = new NewProxyResultSet( innerResultSet, parentPooledConnection, inner, this );
		}
		
		return out;
	}
	
	void maybeDirtyTransaction()
	{ creatorProxy.maybeDirtyTransaction(); }
}
